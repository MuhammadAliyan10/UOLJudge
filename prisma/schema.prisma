// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// --- ENUMS ---
enum UserRole {
  ADMIN       // Full Access
  JURY        // Can Grade & View Logs
  PARTICIPANT // Restricted View
}

enum Category {
  CORE
  WEB
  ANDROID
}

enum Verdict {
  PENDING
  ACCEPTED
  REJECTED
  RUNTIME_ERROR // Code crashed
  COMPILE_ERROR // Syntax error
}

enum LogAction {
  LOGIN
  SUBMISSION
  MANUAL_GRADE_UPDATE
  BAN_USER
  CONTEST_UPDATE
  // ADDED: RESTORE_SCORE (For logging undo actions)
  RESTORE_SCORE
}

// --- MODELS ---

model User {
  id            String   @id @default(uuid())
  username      String   @unique
  password_hash String
  role          UserRole @default(PARTICIPANT)

  is_active     Boolean  @default(true) // Used for banning/suspension
  created_at    DateTime @default(now())

  // Relations (User is the center of all activity)
  team_profile     TeamProfile?
  submissions      Submission[]        @relation("SubmittedBy") // Submissions made by this user
  judged_submissions Submission[]        @relation("JudgedBy")   // Submissions judged by this user
  contest_registrations ContestRegistration[] // NEW: Enrollment link

  sent_clarifications     Clarification[] @relation("SentBy")
  answered_clarifications Clarification[] @relation("AnsweredBy")

  logs             SystemLog[] // Tracks what this user did
}

model TeamProfile {
  id           String   @id @default(uuid())
  user_id      String   @unique
  user         User     @relation(fields: [user_id], references: [id], onDelete: Cascade) // If User is deleted, profile is deleted

  display_name String
  members      Json     @default("[]")
  lab_location String?
  category     Category

  // CACHING FOR FINAL RESULT PAGE (O(1) read time for leaderboard)
  total_score   Int      @default(0)
  total_penalty Int      @default(0)
  rank          Int?
}

// NEW: ISOLATION LAYER
// Ensures a team is explicitly linked to a contest and guards against contest deletion
model ContestRegistration {
  id          String   @id @default(uuid())
  user_id     String
  contest_id  String
  registered_at DateTime @default(now())

  user        User     @relation(fields: [user_id], references: [id], onDelete: Cascade)
  contest     Contest  @relation(fields: [contest_id], references: [id], onDelete: Restrict) // PREVENTS CONTEST DELETE IF TEAMS ARE REGISTERED

  @@unique([user_id, contest_id])
  @@map("ContestRegistration")
}


model Contest {
  id         String   @id @default(uuid())
  name       String
  start_time DateTime
  end_time   DateTime

  frozen_at  DateTime?
  is_active  Boolean  @default(true)
  config     Json     @default("{}")

  // Relations
  problems   Problem[]                @relation("ContestProblems")
  announcements Announcement[]        @relation("ContestAnnouncements")
  registrations ContestRegistration[] // NEW: Link back to teams
}

model Problem {
  id          String   @id @default(uuid())
  order_index Int      @default(0)

  title       String
  description String   @db.Text
  category    Category
  points      Int      @default(100)

  time_limit_sec   Float?  @default(2.0)
  memory_limit_mb  Int?    @default(256)

  assets_path String?

  contest_id  String
  contest     Contest  @relation("ContestProblems", fields: [contest_id], references: [id], onDelete: Cascade) // If contest dies, problems die

  submissions    Submission[]
  clarifications Clarification[]
}

model Submission {
  id        String   @id @default(uuid())

  file_path String
  file_hash String
  language  String?
  verdict   Verdict  @default(PENDING)

  auto_score    Int      @default(0)
  manual_score  Int?
  final_score   Int      @default(0)

  penalty       Int      @default(0)

  submitted_at DateTime @default(now())

  // Relations
  user_id   String
  user      User     @relation("SubmittedBy", fields: [user_id], references: [id], onDelete: Cascade) // If user dies, submissions die
  problem_id String
  problem    Problem @relation(fields: [problem_id], references: [id], onDelete: Cascade) // If problem dies, submissions die

  judged_by_id String?
  judged_by    User?    @relation("JudgedBy", fields: [judged_by_id], references: [id])

  jury_comment String? @db.Text
}

model Clarification {
  id        String   @id @default(uuid())
  question  String   @db.Text
  answer    String?  @db.Text

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  problem_id String?
  problem    Problem? @relation(fields: [problem_id], references: [id], onDelete: SetNull) // Clarification can exist without problem

  user_id   String
  user      User   @relation("SentBy", fields: [user_id], references: [id], onDelete: Cascade)
  answered_by_id String?
  answered_by    User?   @relation("AnsweredBy", fields: [answered_by_id], references: [id])
}

model Announcement {
  id         String   @id @default(uuid())
  title      String
  message    String   @db.Text
  created_at DateTime @default(now())

  contest_id String
  contest    Contest @relation("ContestAnnouncements", fields: [contest_id], references: [id], onDelete: Cascade)
}

// NEW: Security Logs (The "Black Box")
model SystemLog {
  id        String   @id @default(uuid())
  action    LogAction
  details   String
  ip_address String?

  timestamp DateTime @default(now())

  // NEW: Link the log directly to the source of the action
  submission_id String?

  user_id   String?
  user      User?    @relation(fields: [user_id], references: [id])
}
